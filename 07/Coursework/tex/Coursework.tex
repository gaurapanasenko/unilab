%!TEX TS-program = xelatex
%!TEX encoding = UTF-8 Unicode

\documentclass[14pt,a4paper]{extarticle}

\usepackage{mathtools} % Mathematical tools to use with amsmath
%\usepackage{amsfonts} % TeX fonts from the American Mathematical Society
\usepackage{ifxetex}
\usepackage{indentfirst} % Indent first paragraph after section header
\ifxetex
  \usepackage{mathspec} % Specify arbitrary fonts for mathematics in XeTeX
  \usepackage{fontspec} % Advanced font selection in XeLaTeX and LuaLaTeX
  \usepackage{polyglossia} % Multilingual support for XeLaTeX
\else
  \usepackage[T1]{fontenc}
  \usepackage[utf8x]{inputenc}
  \usepackage[ukrainian]{babel}
\fi
\usepackage[
  left=2.5cm,right=1.5cm,top=1.5cm,bottom=1.5cm,
  headheight=5mm,headsep=5mm,includehead
]{geometry} % Flexible and complete interface to document dimensions
\usepackage{makeidx} % Standard LaTeX package for creating indexes
\usepackage[
  colorlinks=true, allcolors=black,
]{hyperref} % Extensive support for hypertext in LaTeX
\usepackage{titlesec} % Select alternative section titles
\usepackage{array} % Extending the array and tabular environments
\usepackage{amsthm} % Typesetting theorems (AMS style)
%\usepackage{mathrsfs} % Support for using RSFS fonts in maths
\usepackage{amssymb}

\usepackage{cprotect}% http://ctan.org/pkg/cprotect
\usepackage{listings} % Typeset source code listings using LaTeX
\usepackage{minted}
\usepackage{fancyhdr}
\usepackage{ulem}
\usepackage{multicol}
\usepackage[nottoc]{tocbibind}
%\usepackage{longtable}
%\usepackage{pgfplots} % Create normal/logarithmic plots !slow
\usepackage{titletoc}
\usepackage{pgf}
\usepackage{tikz}
\usepackage[section]{placeins}
\usepackage[labelsep=period,bf,textfont=bf]{caption}
\usepackage{pst-node, pst-plot, auto-pst-pdf}
\usepackage{setspace}

% latex
\pagestyle{myheadings}

\ifxetex
  % mathspec
  \setmathsfont(Digits,Latin,Greek){Times New Roman}

  % fontspec
  \defaultfontfeatures{Mapping=tex-text}
  \setmainfont{Times New Roman}
  \setmonofont[Mapping=tex-text]{Fantasque Sans Mono}
  \newfontfamily\cyrillicfont{Times New Roman}
  \newfontfamily\cyrillicfontsf[Script=Cyrillic]{Fantasque Sans Mono}
  \newfontfamily\cyrillicfonttt[Script=Cyrillic]{Fantasque Sans Mono}

  % polyglossia
  \setdefaultlanguage{ukrainian}
\fi

% titlesec
\titleformat{\section}
  {\newpage\normalfont\Large\bfseries\centering\MakeUppercase}{\thesection. }{0pt}{}
\titleformat{\subsection}
  {\normalfont\large\bfseries\centering}{\thesubsection. }{0pt}{}
\titleformat{\subsubsection}
  {\normalfont\bfseries}{\thesubsubsection. }{0pt}{}
%\titlespacing\section{0pt}{0pt plus 0pt minus 0pt}{0pt plus 0pt minus 0pt}
%\titlespacing\subsection{0pt}{0pt plus 0pt minus 0pt}{0pt plus 0pt minus 0pt}
%\titlespacing\subsubsection{0pt}{0pt plus 0pt minus 0pt}{0pt plus 0pt minus 0pt}

% array
\def\arraystretch{1.5}

% listed
\lstset{language=C++,
  basicstyle=\ttfamily,
  keywordstyle=\color{blue}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  commentstyle=\color{green}\ttfamily,
  morecomment=[l][\color{magenta}]{\#}
}

% minted
\newminted{python}{linenos,breaklines,breakanywhere}
\newmintinline{python}{showspaces}
\newminted{html}{baselinestretch=0.6,fontsize=\tiny,breaklines,breakanywhere}
\newmintinline{html}{showspaces}

% amsthm
\newtheorem{theorem}{Теорема}[section]
\theoremstyle{definition}
\newtheorem{definition}{Визначення}[section]

\linespread{1.5}
\setlength{\parindent}{1cm}
\setlength{\parskip}{0.5\baselineskip}%
\bibliographystyle{plain}
%\dottedcontents{section}[1em]{}{1.5em}{1pc}
%\dottedcontents{subsection}[2.5em]{}{2em}{1pc}
\titlecontents*{section}[0cm]{\small}{\thecontentslabel. \uppercase}{\uppercase}{ \titlerule*[1pc]{.}\contentspage\\}[][]
\titlecontents*{subsection}[0cm]{\small}{\hspace*{1cm}\thecontentslabel. }{}{ \titlerule*[1pc]{.}\contentspage\\}[][]
\titlecontents*{subsubsection}[0cm]{\small}{\hspace*{2cm}\thecontentslabel. }{}{ \titlerule*[1pc]{.}\contentspage\\}[][]

\makeatletter
\def\@maketitle{%
  \newpage%
  \linespread{1}\rmfamily%
  \begin{center}%
    {\bfseries ДНІПРОВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ \\%
    ІМЕНІ ОЛЕСЯ ГОНЧАРА \\%
    ФАКУЛЬТЕТ ПРИКЛАДНОЇ МАТЕМАТИКИ \\%
    КАФЕДРА КОМП'ЮТЕРНИХ ТЕХНОЛОГІЙ \\}%
  \end{center}%
  \vspace*{5pt}%
  {\@title \par}%
  \hfill \break%
  \begin{flushright}%
    {\linespread{1}%
      \begin{tabular}[b]{p{8cm}}%
        \@author%
      \end{tabular}\par}%
  \end{flushright}
  \vspace*{\fill}
  {\centering м. Дніпро, 2020 р.\par}}
\makeatother

\makeatletter
%\renewcommand{\[}{\begin{dmath*}[compact]}
%\renewcommand{\]}{\end{dmath*}}
%\newcommand{\bdg}{\begin{dgroup*}}
%\newcommand{\edg}{\end{dgroup*}}
%\newcommand{\bdg}{}
%\newcommand{\edg}{}
\renewcommand{\[}{\begin{singlespace}\begin{equation*}}
\renewcommand{\]}{\end{equation*}\end{singlespace}}
\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}
\newcommand{\ds}{\displaystyle}
\newcommand{\sep}{ , \ \allowbreak }
\newcommand{\ivr}{\rule[-2.25ex]{0pt}{6ex}}
\newcommand\fr[2]{\dfrac{#1}{#2}}
\newcommand{\sigmalgebra}{\text{\textcircled{$\sigma$}}}
\newcommand\uname[3]{\parbox[b][\height][b]{#1}{\tiny\underline{\normalsize\parbox[c][4mm][t]{#1}{\makebox[#1]{#2}}}\newline\makebox[#1]{(#3)}}}
\newcommand\eeq[1][]{\stackrel{\mathclap{\normalfont\mbox{#1}}}{=}}
\renewcommand{\@biblabel}[1]{#1.}
\addto\captionsukrainian{\renewcommand{\refname}{СПИСОК ВИКОРИСТАНОЇ ЛІТЕРАТУРИ}}
\addto\captionsukrainian{\renewcommand{\figurename}{Рис.}}
\makeatother

\title{\begin{center}
    {\bfseries КУРСОВА РОБОТА\\
    ЗА ФАХОВИМ СПРЯМУВАННЯМ}\\
    \raggedright на тему: Комп'ютерне моделювання поведінки динамічних об'єктів в комп'ютерних іграх \\
  \end{center}
  Освітньо-професійна програма: Комп'ютерне моделювання та технології програмування\\[3mm]
  Спеціальність: 113 Прикладна математика\\[3mm]
  Галузь знань: 11 Математика і статистика\\[3mm]
  Рівень вищої освіти: перший (бакалаврський)}
\author{Cтудента 4 курсу групи ПА–17–2 \newline%
  \uname{8cm}{Панасенко Єгор Сергійович}{прізвище та ініціали}\newline\newline
  Керівник: \uline{канд. фіз.-мат. наук\hfill} \newline%
  \uname{8cm}{Степанова Наталія Іванівна}{посада, вчене звання, науковий ступінь, прізвище та ініціали} \newline\newline
  Кількість балів: \uline{\hfill}\newline\newline
  Національна шкала: \uline{\hfill}\newline\\
  \bgroup
  %\def\arraystretch{1}
  \begin{tabular}[b]{@{}p{3cm}@{}p{5cm}@{}}
    \multicolumn{2}{l}{Члени комісії:}\\
    \uname{3cm}{\hfill}{підпис}
      & \uname{5cm}{Зайцева Т.А.}{прізвище та ініціали} \\
    \uname{3cm}{\hfill}{підпис}
      & \uname{5cm}{Сердюк М.Є.}{прізвище та ініціали} \\
    \uname{3cm}{\hfill}{підпис}
      & \uname{5cm}{Дзюба П.А.}{прізвище та ініціали} \\
  \end{tabular}\egroup\par}
\date{}

\begin{document}
\stepcounter{tocdepth}
\sloppy % Stretches spaces to correct align of text
\allowdisplaybreaks % Breaks equations between pages
\maketitle
\thispagestyle{fancy}
\fancyhf{}% Clear all headers/footers
\renewcommand{\headrulewidth}{0pt}% No header rule
\renewcommand{\footrulewidth}{0pt}% No footer rule

\section*{РЕФЕРАТ}
\addcontentsline{toc}{section}{РЕФЕРАТ}
Курсова робота: \_\_ с., \_ рис., \_ джерел, \_ додаток.

Об'єкт дослідження: динамічні гладкі об'єкти у комп'ютерній графіці.

Мета роботи: Розробити програмне забезпечення для моделювання зіткнень динамічних гладких об'єктів у режимі реального часу.

Одержані висновки та їх новизна: запропоновані підходи до моделювання динамічних гладких об'єктів та розроблено програмне забезпечення для відображення цих об'єктів.

Результати досліджень можуть бути використані для розробки комп'ютерних ігор та симуляції бою у єдиноборствах для перевірки ефективності прийомів. 

Перелік ключових слів: OPENGL, КРИВІ БЕЗЬЄ, ПОВЕРХНІ БЕЗЬЄ, C, GLM, NUKLEAR, МАТЕМАТИЧНА МОДЕЛЬ ПОВЕРХНІ.

\tableofcontents
\section*{ВСТУП}
\addcontentsline{toc}{section}{ВСТУП}
У сучасному світі спостерігається неймовірний приріст потужності обчислювальної техніки і розробники ігор намагаються використати цю потужність найбільш ефективно з метою отримання графіки, найбільш схожої на реальний світ.

Для досягнення найбільшого задоволення розробники також намагаються створити якомога більше ігрових об'єктів та приголомшливих ефектів, що супроводжується значним споживання дискового простору й оперативної пам'яті. Тому завжди є актуальним питання розробки більш ефективних методів моделювання ігрових об'єктів, які б використовували менше обчислювальних ресурсів.

Деякий час тому, коли потужність обчислювальних засобів достатньо виросла, було створено векторний формат зберігання зображень SVG, призначений для зберігання як статичної, так і анімованої двомірної графіки. Для побудови зображень SVG формат використовує криві Безьє, які у свою чергу є окремим випадком B-сплайна. Формат SVG підтримується всіма сучасними браузерами для настільних і мобільних пристроїв.

Як відомо, векторним форматам притаманні гарна масштабованість й незначне використання дискового простору за умови, що зображення складається з невеликої кількості простих елементів. З іншого боку, векторні формати мають також і недоліки: у порівнянні з растровими аналогами для побудови векторних зображень використовується більше процесорного часу, а складні зображення починають використовувати більше дискового простору ніж аналогічні растрові.

У трьохвимірному просторі найбільш розповсюдженим форматом є OBJ - гнучкий формат, що дозволяє створювати об'єкти за допомогою різних способів, у тому числі з використанням кривих Безьє і B-сплайнів.

Таким чином вже існують формати, які дозволяють зберігати об'єкти компактно, забезпечувати їх легку масштабованість. Але у реальному ігровому процесі, де об'єкти сцени постійно взаємодіють один з одним, виникає проблема: як визначити коли об'єкти перетнулися або зіткнулися, під яким кутом це сталося?

У даному дослідженні поставлено задачу розробки ефективного алгоритму, що дозволить у режимі реального часу визначати місце та кут зіткнення декількох об'єктів, побудованих за допомогою сплайн-технологій. Також потрібно виконати програмну реалізацію, яка цей алгоритм використовує.

Для розробки програмного продукту обрано крос-платформовий програмний інтерфейс OpenGL, що забезпечує незалежність програмного додатку від операційної системи.

\section*{ПОСТАНОВКА ЗАДАЧІ}
\addcontentsline{toc}{section}{ПОСТАНОВКА ЗАДАЧІ}

Метою цієї курсової роботи є розробка програмного забезпечення для моделювання зіткнень динамічних гладких об'єктів у режимі реального часу. У загальному випадку розглядаються динамічні об'єкти створені за допомогою поверхонь Безьє. Для досягнення поставленої мети були поставлені наступні задачі:

\begin{itemize}
\item дослідити математичні моделі динамічних гладких об'єктів та вибрати оптимальний спосіб для розв'язання поставленої задачі,
\item розробити програмне забезпечення для відображення динамічних об'єктів,
\item розробити програмне забезпечення для створення або редагування динамічних об'єктів.
\end{itemize}

\section{Аналітичний огляд літературних джерел}

\subsection{Математичні моделі поверхонь та об'єктів}

Комп'ютерна графіка пропонує сьогодні різні засоби моделювання просторових форм і об'єктів. Геометричне моделювання - це математичний опис об'єктів у просторі певними атрибутами: координатами, розмірами, формою. При відображенні геометричних об'єктів потрібно враховувати також їх просторове розташування і поведінку: переміщення, повороти відносно координатних осей ( шість ступенів свободи), зіткнення з перешкодами або іншими об'єктами. Крім цього для отримання образів просторових форм на площині екрану необхідно використовувати ще одне геометричне перетворення - проеціювання.
Існує така класифікація моделей поверхонь і об'єктів:

Існує така класифікація поверхонь:
\begin{itemize}
\item Каркасні - на екран друкуються не всі точки поверхні, а лише невелика кількість, що реалістично передає характер поверхні. З цих точкок будуємо систему ліній на поверхні і отримаємо каркас.
\item Точкові - на екран друкуються точки з відповідним забарвленням.
\item Кінематичні - поверхня будується неперервним рухом у просторі лінії по деякій траєкторії.
\item Кусочні, яка при обмеженому набору даних будує поверхню у якій присутні розриви ти злами.
\item Сплайнові, використовується для побудови гладких поверхонь на основі обчислення координат за допомогою СЛАУ, або його модифікацію.
\item Фрактальні, використовує властивість об'єктів до самоподібності в залежності від масштабу.
\item Графічні використовуєтся у разі, якщо не можливо виділити деякий закон для побудови і поверхня заповнюється деякими дискретними елементами, названими вокселами.
\end{itemize}

\subsection{Дослідження математичних моделей динамічних гладких об'єктів}

Серед існуючи математичних моделей поверхонь та об'єктів було вибрано саме поверхню Безьє, яка є частинним випадком B-сплайнів.

\subsubsection{Сплайнові криві}

Розглянемо загальний випадок спланової кривої. Нехай існують вектори $u_i, i=\overline{0,n}$, ці вектори називаються вузлові точки, довжина вектора залежить від розмірності простору у якому ми працюємо, для двомірного простору $u_i = [x_i\ y_i]$, для трьохмірного $u_i = [x_i\ y_i\ z_i]$. Надалі будемо розглядати трьохмірний простір. Нехай ці вузлові точки пронумеровані у порядку з'єднання кривої.

Існують координатний вид кривої
\[\left\{\begin{array}{l}
x_i(t)=s_{3x_i}t^3+s_{2x_i}t^2+s_{0x_i}t+s_{1x_i}\\
y_i(t)=s_{3y_i}t^3+s_{2y_i}t^2+s_{0y_i}t+s_{1y_i}\\
z_i(t)=s_{3z_i}t^3+s_{2z_i}t^2+s_{0z_i}t+s_{1z_i}\\
\end{array}\right.\]
та векторний
\[\left\{\begin{array}{l}
p_i(t)=[t^3\quad t^2\quad t\quad 1]\ S_i\\
\forall t \in [0, d_i],\ i = \overline{0,n}
\end{array}\right.\text{, де }S_i=\left[\begin{matrix}
s_{3x_i} && s_{3y_i} && s_{3z_i} \\
s_{2x_i} && s_{2y_i} && s_{2z_i} \\
s_{1x_i} && s_{1y_i} && s_{1z_i} \\
s_{0x_i} && s_{0y_i} && s_{0z_i} \\
\end{matrix}\right]\]

Загалом на основі властивостей сплайнів будується СЛАУ
\[QS=U \to S=Q^{-1}U\]

\subsubsection{Крива Безьє}

\begin{figure}[!htb]
    \centering
    \def\svgwidth{\columnwidth}
    \input{bezier_3_big.tex}
    \caption{Будування кривої Безьє}\label{fig:bezier_3_big}
\end{figure}

Розглянемо графічний спосіб побудови кубічної кривої Безьє, який проілюстрований на рис. \ref{fig:bezier_3_big}. Нехай у нас є деяке дійсне число $t=0.25$, загалом $t \in [0,1]$, і $P_i, i=\overline{0,3}$ - це контрольні точки кривої Безьє на першому кроці ми відкладаємо $0.25$ шляху на відрізках $P_iP_{i+1}$, отримаємо точки $Q_{j}, j=\overline{0,2}$, на наступному кроці робимо теж саме і отримаємо $R_0$ та $R_1$, на даному етапі ми отримали дотичну до кривої, ця властивість буде використана для побудови нормалі у поверхні кривої Безьє. І знову прокладемо $0.25$ шляху на відрізку $R_0R_1$ отримаємо нашу точку $B$, яка знаходиться на кривій. Якщо ми будемо послідовно виберати $t$, наприклад з кроком $0.1$, та з'єднувати у відрізки, то ми отримаємо ламану і з зменшенням кроку ми будемо отримувати ламану більш схожу на криву, таким чином можна підібрати такий крок, при якому на екрані комп'ютера буде відображатися крива.

Крива Безьє задається формулою:
\[B(t)=\sum_{i=0}^n P_i b_{i,n}(t)\]
де $P_i$ - контрольні точки, а $b_{k,n}(t)$ - поліноми Бернштейна, базисні функції кривої Безьє.
\[b_{k,n}(t)=C_i^nt^k(1-t)^{n-k}\]
де $C_i^n$ число поєднань з $n$ по $k$
\[C_i^n=\frac{n!}{k!(n-k)!}\]

Побудуємо формулу кубічної кривої Безьє:
\[B(t)=(1-t)^3P_0+t(1-t)^2P_1+t^2(1-t)P_2+t^3P_3\]

Цю формулу можна отримати побудувавши криву графічним способом. Прокласти шлях від однієї контрольної точки до іншої можна таким чином $(1-t)P_i+tP_{i+1}$, якщо ми послідовно проробимо ті самі кроки, що і у графічному будуванні, отримаємо:
\begin{align*}
B(t)=&t (t ((1 - t) P_{2} + t P_{3}) + (1 - t) ((1 - t) P_{1} + t P_{2})) +\\
&+(1 - t) (t ((1 - t) P_{1} + t P_{2}) + (1 - t) ((1 - t) P_{0} + t P_{1}))
\end{align*}

Спростимо формулу:
\begin{equation}
\label{eq:bezier_curve}
B(t) = -t^3P_0+3t^3P_1-3t^3P_2+t^3P_3 + 3t^2P_0-6t^2P_1+3t^2P_2 - 3tP_0+3tP_1 + P_0
\end{equation}

Тепер ми можемо записати формулу у матричному вигляді:
\[B(t)=[t^3\quad t^2\quad t\quad 1]\left[\begin{matrix}
-1 &  3 & -3 & 1 \\
 3 & -6 &  3 & 0 \\
-3 &  3 &  0 & 0 \\
 1 &  0 &  0 & 0 \\
\end{matrix}\right]\left[\begin{matrix}
P_0 \\ P_1 \\ P_2 \\ P_3 \\
\end{matrix}\right]\]
aбо нехай $P_i = [p_{ix}\ p_{iy}\ p_{iz}\ 1]$
\[B(t)=[t^3\quad t^2\quad t\quad 1]\left[\begin{matrix}
-1 &  3 & -3 & 1 \\
 3 & -6 &  3 & 0 \\
-3 &  3 &  0 & 0 \\
 1 &  0 &  0 & 0 \\
\end{matrix}\right]\left[\begin{matrix}
p_{0x} & p_{0y} & p_{0z} & 1 \\
p_{1x} & p_{1y} & p_{1z} & 1 \\
p_{2x} & p_{2y} & p_{2z} & 1 \\
p_{3x} & p_{3y} & p_{3z} & 1 \\
\end{matrix}\right]\]

Враховуючи що на сучасних комп'ютерах завдяки кешуванню рядків, то множити матрицю на вектор швидше ніж вектор на матрицю, то більш оптимальною формулою буде: 
\[B(t)=\left[\begin{matrix}
p_{0x} & p_{0y} & p_{0z} & 1 \\
p_{1x} & p_{1y} & p_{1z} & 1 \\
p_{2x} & p_{2y} & p_{2z} & 1 \\
p_{3x} & p_{3y} & p_{3z} & 1 \\
\end{matrix}\right]^T\left[\begin{matrix}
-1 &  3 & -3 & 1 \\
 3 & -6 &  3 & 0 \\
-3 &  3 &  0 & 0 \\
 1 &  0 &  0 & 0 \\
\end{matrix}\right]\left[\begin{matrix}t^3\\t^2\\t\\1\end{matrix}\right]\]

Тепер знайдемо похідну до вираження (\ref{eq:bezier_curve}), для того щоб знайти дотичну, отримаємо:
\begin{equation}
B(t) = -3t^2P_0+9t^2P_1-9t^2P_2+3*t^2P_3 + 6tP_0-12tP_1+6tP_2 - 3P_0+3P_1
\end{equation}

Запишемо у матричному вигляді:
\[B(t)=\left[\begin{matrix}
p_{0x} & p_{0y} & p_{0z} & 1 \\
p_{1x} & p_{1y} & p_{1z} & 1 \\
p_{2x} & p_{2y} & p_{2z} & 1 \\
p_{3x} & p_{3y} & p_{3z} & 1 \\
\end{matrix}\right]^T\left[\begin{matrix}
 0 &   0 &  0 & 0 \\
-3 &   9 & -9 & 0 \\
 6 & -12 &  6 & 0 \\
-3 &   3 &  0 & 0 \\
\end{matrix}\right]^T\left[\begin{matrix}t^3\\t^2\\t\\1\end{matrix}\right]\]

Властивості кривої Безьє:
\begin{itemize}
\item неперервність заповнення сегменту між початковою та кінцевою точками,
\item крива завжди знаходитися у фігурі утвореній контрольними точками, у кубічній кривій це буде деякий чотирикутник, цю властивість можна використати для того щоб перевірити чи не перетинаються дві криві на початковому етапі,
\item якщо контрольні точки знаходяться на одній прямій, то утворюється пряма лінія,
\item крива симетрична, тобто якщо переставити вектор контрольних точок у зворотьому порядку, то отримаємо ту саму форму,
\item крива афінно інваріантна,
\item зміна однієї контрольної точки приводить до зміни всієї кривої,
\item будь який сегмент кривої є крива Безьє.
\end{itemize}

\subsubsection{Поверхня Безьє}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=0.5\textwidth]{bezier-surface.png}
    \caption{Будування поверхні Безьє}\label{fig:bezier-surface}
\end{figure}

Розглянемо графічний спосіб побудови кубічної поверхні Безьє з 16 контрольними точками. Спочатку ми будуємо 4 кубічні криві Безьє через контрольні точки 1-4, 5-8, 9-12, 13-16 використовуючи дійсне число $v$, далі використовуючи точки відповідних $v$ на отриманих кривих як контрольні точки наступної кривої будуємо наступну криву використовуючи дійсне число $u$, таким чином ми отримаємо поверхню побудованої з багатьох кривих, причому як ми все знаємо відрізок отриманий в останньому кроці при побудові кривої це дотична, якщо ми побудуємо поверхню будуючи криві по контрольним точкам 1, 5, 9, 13 і так далі до 4, 8, 12, 16, то ми отримаємо ще одну дотичну, але в деякому іншому напрямку, і якщо ми знайдемо векторний добуток отриманих дотичних, ми отримаємо нормаль до поверхні у данній точці.

Крива Безьє задається формулою:
\[p(u,v)=\sum_{i=0}^n\sum_{j=0}^n b_{i,n}(u) b_{j,n}(v) P_{ij}\]

\subsection{Бібліотека Visualization Library}

У ході роботи було знайдено таку біблиотеку, як Visualization Library. Це біблиотека написана на мові C++ і може використовуватись для графіки у 2D або 3D. Вона дозволяє моделювати різні види поверхонь, фрактали, та багато іншого.

Зробимо аналіз цієї бібліотеки.

\begin{itemize}
\item Бібліотека написана на мові C++, тобто це звужує кількість мов, що можуть використовувати цю бібліотеку.
\item Бібліотека самостійно реалізує свою матрицю та вектор, таким чином закривають можливість оптимізувати операції над матрицями. Більш того бібліотека не  використовує команди SSE, які дають приріст у швидкості, як це зроблено у бібліотеці CGLM.
\item Бібліотека вже не підтримується розробниками, останній внесення змін у код було 20 лютого 2020 року, у порівнянні з бібліотекою CGLM, яка активно розвивається.
\item Якщо подивитися на реалізацію кривих Безьє, то ми побачимо, що бібліотека не використовує матричний спосіб отримання вершин з поверхні Безьє, таким чином ми знову не можемо використати оптимізацію за допомогою команд SSE.
\item Також перерірено спосіб знаходження нормалей для поверхні, біблиотека знаходить нормалі по отриманим трикутникам при будуванні поверхні, хоча для поверхні Безьє існує значно швидший та дешевший спосіб знаходження нормалі, цей спосіб будується на знаходження похідних до кривої Безьє з різних сторін.
\end{itemize}

\section{Вимоги до розробленого програмного забезпечення}

Для розробки програмного забезпечення висунуто такі вимоги:
\begin{itemize}
\item Програмне забезпечення повинно мати відкритий вихідний код та ліцензію вільного програмного забезпечення.

Це дозволить будь якому досвідченому користувачу зкомпілювати програмне забезпечення під будь яку платформу та операційну систему, або навіть дасть можливість модифікувати код під свої потреби.

Також ліцензія повинна бути сумісна з ліцензіями використаних бібліотек. Загалом були використані бібліотеки CGLM, Nuklear, GLFW, uthash та прогрмний інтерфейс OpenGL. Перші біблиотеки CGLM та Nuklear використовують ліцензію MIT, бібліотека GLFW використовує ліцензію ZLib, а uthash -- ліцензію BSD. А програмний інтерфейс OpenGL має ліцензію подібну до ліцензії BSD. Усі ці ліцензії є сумісними з ліцензією LGPLv3, яка є подібною до GPL, але дозволяє використовувати програмне забезпечення у пропріетарних проектах.

\item Програмне забезпечення повинно працювати у режимі реального часу.

Саме таким чином було вибрано мову C та бібліотеку CGLM, які дозволяють досягти найбільшої швидкості роботи програми у порівнянні з іншими мовами програмуванні, причому практично не знижуючи швидкості розробки коду. Більш того CGLM автоматично компілюється з використанням SSE команд, якщо є така можливість, що ще дає приріст у швидкості.

\item Програмне забезпечення повинно дати можливість використання бібліотеки якомога більшому колу розробників.

Це ще одна причина вибору мови C, яку можна обернути у більшість мов програмування і таким чином програмне забезпечення зможуть використати і розробники, які не знають C, але знають деяку іншу мову програмування.

\item Програмне забезпечення повинно бути якомога простим та легким, та залежати від простих та легких бібліотек.

Програмне забезпечення повинно розроблятися по принципу KISS (акронім для ``Keep it simple, stupid''), що означає що проектування повинно бути якомога простішим. Таким чином можна уникнути багатьох помилок пов'язані з тим що неможливо розробник не може охопити структуру вихідного коду складного програмного забезпечення, а також таке програмне забезпечення має дуже малий розмір зкомпільованої програми, що підвищує легкість розповсюдження. І це третя причина чому було вибрано саме мову програмування C, яка має дуже простий синтаксис та просту структуру. А також саме тому було вибрано саме такий набір бібліотек, а загалом графічну бібліотеку Nuklear, яка має досить невеликий обсяг коду, приблизно 30 тисяч строк коду разом з коментарями.
\end{itemize}


\section{Опис програмного забезпечення}

Було розроблено програмне забезпечення на мові Сі для моделювання поверхні Безьє за допомогою програмного інтерфейсу OpenGL, що використовується для відображення 2D та 3D векторної графіки на екран, основна особливість, чому була вибрано саме OpenGL це те що інтерфейс має вільну ліцензію подібну до BSD, її підтримують більшість оперативних систем та інтерфейс на мові Сі. Також були використані бібліотеки:

\begin{itemize}
\item CGLM - математична бібліотека написана на мові Cі. Використовує ліцензію MIT.

У программі загалом використовується для афінних перетворень та арифметичними операціями між матрицями. За замовчанням використовує команди SSE, що дозволяють прискорити швидкість обчислення завдяки повному виковистанню особливостей обчислення процесорів.

\item Nuklear - бібліотека для графічного інтерфейсу написана на мові Сі. Використовує ліцензію MIT.

Бібліотека має невелику кодову базу порівняно з аналогічними графічними бібліотеками та фреймворками, такими як GTK або QT, та дозволяє створювати динамічні віджети.

\item GLFW - бібліотека для відображення вікна з OpenGL та обробки вводу. Використовує ліцензію ZLib.

\item uthash - біблиотека для динамічних масивів та хеш таблиць. Використовує ліцензію BSD.

Завдяки тому що на мові Сі відсутні стандартні структури даних, ця біблиотека дозволяє створювати динамічні масиви, хеш таблиці, та багато іншого для різних типів даних та структур, завдяки цьому ми можемо працювати так само як і на більшості мовах програмування та навіть з більшою швидкістю. Аналогічно як і бібліотека Nuklear, бібліотека uthash має дуже малу кодову базу, варіативніть типів реалізується за допомогою макросів, що також зменшує кількість коду і відповідає принципу програмування DRY (акронім ``don't repeat yourself'').
\end{itemize}

Код програмного забезпечення складається з таких компонентів:
\begin{itemize}
\item Вихідний код програми, який зберігається у директорії ``src'' (скорочено ``source''). Загалом тут знаходяться файли заголовків з розширенням ``.h'' та з реалізацією з розширенням ``.c'', кожен файл заголовків у цій директорії утворює окремий модуль, подібний класу у парадигмі об'єктно орієнтованого програмування.
\item Ресурси програми, які зберігаються у директорії ``res'' (скорочено ``resource''). Тут знаходяться шейдери та тестові моделі чайнику та деякої еліпсоподібної моделі.
\item Файл з правилами компіляції для CMake. CMake дозволяє компілювати програму незалежно від платформи, більш того дозволяє створити інсталяційний файл на цю платформу.
\end{itemize}

Після компіляції ми отримаємо нашу програму у директорії ``bin'' та ресурси у директорії ``share/osdo'', ця структура директорії Unix подібна.

\section{Опис модулів програми}

Програма складається з декількох модулів, загалом вони реалізуються деяку структуру за поняттям дуже подібною, що у парадигмі об'єктно орієнтованого програмування (далі ООП), навіть використовується принципи поліморфізму, як наприклад у модулях ``Bijective'' та ``Model'', та інкапсуляції, як наприклад у модулі ``Window''.

\begin{itemize}
\item Модуль ``App'' (файли ``app.h'' та ``app.c'') --- компонує разом сцену, вікно, шейдери та об'єкти. Тут реалізується основна поведінка всієї програми, тобто головний виконуваний цикл.

\item Модуль ``Beziator'' (файли ``beziator.h'' та ``beziator.c'') --- читає з файлу, назва якого була вказана у конструкторі, модель, побудовану з поверхонь Безьє. Модуль зберігає саму модель, дозволяє її змінювати та згенерувати з моделі новий меш, який відобразиться на екрані. Також у цьому модулі однією константою зафіксовано ступінь деталізації об'єкту.

\item Модуль ``Bijective'' (файли ``bijective.h'' та ``bijective.c'') --- модуль за поняттям подібний до абстрактного класу з парадигми програмування ООП. Дозволяє трансформувати деякий об'єкт у просторі, використовується для того щоб переміщувати, обертати, анімувати камеру або об'єкт. Таким чином є батьківськім модулем до модуля ``Camera'' та ``Object''. Назва означає що об'єкт бієктивний відносно афінних перетворень.

\item Модуль ``Camera'' (файли ``camera.h'' та ``camera.c'') --- реалізує камеру, зберігає матрицю повороту камери та вектор позиції камери, та дозволяє переміщуватись зміною вектора позиції та повертатись за допомогою афінних перетворень матриці.

\item Модуль ``Conf'' (файли ``conf.h'') --- зберігає необхідні константи для роботи програми, а також початкові значення для об'єктів та деякий приклад мешу куба.

\item Модуль ``Mesh'' (файли ``mesh.h'' та ``mesh.c'') --- модуль зберігає меш об'єкту, та індекси які позначають у OpenGL індекс масиву вершин та сторін. Також модуль дозволяє відображати на екран меш, причому можна зазначити яким чином відображати, як об'єкт, або тільки каркас або вершини. Залежний від файлу заголовків <GL/glew.h>.

\item Модуль ``Model'' (файли ``model.h'' та ``model.c'') --- реалізує абстрактного клас, який дозволяє зберігати повну модель об'єкту для відображення. Модуль є батьківськім до модуля ``Beziator'' та ``Mesh'', що дозволяє відображати на екран як прості поліноми, так і модель задану як поверхня Безьє.

\item Модуль ``Nkglfw'' (файли ``nkglfw.h'' та ``nkglfw.c'') --- модуль потрібний для відображення графічного інтерфейсу Nuklear, історично склалося що nkglfw реалізовувався тільки у зв'язці Nuklear/GLFW/OpenGL, так і виникла назва, пізніше модуль дозволив працювати з власноруч реалізованим вікном з модуля ``Window'', що дозволяє пізніше підключити різні вікна, наприклад SDL до цього самого модуля.

\item Модуль ``Object'' (файли ``object.h'' та ``object.c'') --- утворює об'єкт з моделі (модуль ``Model''), який можна переміщувати, збільшувати, та повертати.

\item Модуль ``Osdo'' (файли ``osdo.h'' та ``osdo.c'') --- задається порядок імпортування бібліотек OpenGL, це пов'язано з тим, що OpenGL дуже строго відноситься до порядку імпортування, наприклад файл заголовків <GL/glew.h> повинен бути імпортований до <GL/gl.h>. Також модуль реалізує макрос ітерації по динамічному масиву з біблиотеки uthash.

\item Модуль ``Scene'' (файли ``scene.h'' та ``scene.c'') --- зберігаються усі перетворення об'єктів та камери, таким чином можна скиданням на параметри за замовчанням ми приводимо сцену до початкового стану.

\item Модуль ``Shader'' (файли ``shader.h'' та ``shader.c'') --- реалізує клас обгортку для завантаження з файлу та компіляції шейдеру. Залежний від файлу заголовків <GL/glew.h>.

\item Модуль ``Window'' (файли ``window.h'' та ``window.c'') --- клас обгортка на вікно з бібліотеки ``GLFW'', модуль приховує реалізацію ``GLFW'', таким чином жоден з модулів не знає об існуванні ``GLFW'' і це дозволяє у подальшому полегшити процес впровадження нового типу вікна, такого як в бібліотеці ``SDL'', наприклад.
\end{itemize}

\section{Огляд роботи програми}

Розглянемо роботу програми.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{screens/example-screen.png}
    \caption{Приклад інтерфейсу}\label{fig:example-screen}
\end{figure}

На мал \ref{fig:example-screen} ми бачимо інтерфейс програми, перша панель складається з таких елементів:
\begin{itemize}
\item переход в режим каркасу (англ. Wireframe),
\item переход у режим світла (англ. Light),
\item переходу між об'єктами, тобто вибираємо активний об'єкт над яким будуть відбуватися операції,
\item позиція об'єкта (англ. Position), що задається вектором у просторі,
\item кут обертання (англ. Rotation) у радіанах навколо відповідної осі глобальної системи координат
\item швидкість обертання, або анімація (англ. Animation), навколо відповідної осі,
\item колір фону (англ. Background).
\end{itemize}

Наступна панель складається з кнопки перегенерування об'єкту, списку контрольних точок та іх координат, далі іде задавання індексів контрольних точок у поверхні.

На малюнках \ref{fig:teapot}, \ref{fig:teapot-light}, \ref{fig:teapot-wireframe} ми бачимо стандартну модель чайнику в різних режимах. Ця модель чайнику стандатрний приклад складної гладкої фігури і називаєтся чайник із Юти (англ. The Utah Teapot) або чайник Н'юелла.

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{screens/teapot.png}
    \caption{Чайник}\label{fig:teapot}
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{screens/teapot-light.png}
    \caption{Чайник із світлом зверху}\label{fig:teapot-light}
\end{figure}

\begin{figure}[!htb]
    \centering
    \includegraphics[width=\textwidth]{screens/teapot-wireframe.png}
    \caption{Карас чайнику}\label{fig:teapot-wireframe}
\end{figure}

\section*{ВИСНОВКИ}
\addcontentsline{toc}{section}{ВИСНОВКИ}
У ході курсової роботи були отримані такі результати:

\begin{itemize}
\item досліджено математичні моделі динамічних гладких об'єктів та вибрано оптимальний спосіб для розв'язання поставленої задачі,
\item розроблене програмне забезпечення для відображення динамічних об'єктів,
\item частково розроблене програмне забезпечення для створення або редагування динамічних об'єктів.
\end{itemize}

\begin{thebibliography}{9}
\bibitem{} Офіційний сайт Міністерства освіти та науки України: http://mon.gov.ua/
\bibitem{} СТП-02066747-009-01. Стандарт Дніпропетровського національного університету. Методика виконання випускних, курсових та дипломних проектів (робіт). Структура, правила оформлення та порядок узгодження і затвердження. Затверджено ректором ДНУ 31.10.2001 р.
\bibitem{} СТП-02066747-010-01. Стандарт Дніпропетровського національного університету. Організація та проведення дипломування. Затверджено ректором ДНУ 1.11.2001 р.
\bibitem{} http://www.dnu.dp.ua/docs/obgovorennya/Polozhennya\_Antiplagiat\_2016.doc
\bibitem{porev} Порев. В.Н. Компъютерная графика -- СПб: БХВ-Петербург, 2002 -- 432 c.
\bibitem{nikulin} Никулин Е. A. Компъютерная геометрия и алгоритмы машинной графики. -- СПб: БХВ-Петербург, 2003 -- 560 c.
\end{thebibliography}

%\end{document}
\section*{Додаток A. Лістинг програми}
\addcontentsline{toc}{section}{Додаток A. Лістинг програми}
\tiny

\end{document}

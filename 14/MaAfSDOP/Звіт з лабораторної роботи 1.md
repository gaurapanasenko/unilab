
<div style="margin: 0; padding:0;font-size: 1.2rem; line-height: 1.5; text-align:center; height: 7cm;">
	<div>МІНІСТЕРСТВО ОСВІТИ ТА НАУКИ УКРАЇНИ</div>
	<div>ДНІПРОВСЬКИЙ НАЦІОНАЛЬНИЙ УНІВЕРСИТЕТ ІМ. О. ГОНЧАРА</div>
	<div>ФАКУЛЬТЕТ ПРИКЛАДНОЇ МАТЕМАТИКИ ТА ІНФОРМАЦІЙНИХ ТЕХНОЛОГІЙ</div>
	<div>КАФЕДРА ОБЧИСЛЮВАЛЬНОЇ МАТЕМАТИКИ ТА МАТЕМАТИЧНОЇ КІБЕРНЕТИКИ</div>
</div>
<div style="margin: 0; padding:0; font-size: 1.4rem; font-weight: bold; text-align:center; height:1cm;">
	ЗВІТ З ЛАБОРАТОРНОЇ РОБОТИ 1
</div>
<div style="margin: 0; padding:0; font-size: 1rem; text-align:center; height:5cm;">
	з дисципліни: "Методи і алгоритми розв'язання задач дискретної оптимізації"
</div>
<div style="margin: 0; padding:0 50px; text-align: right; height:13cm;">
	<div><strong>Виконав:</strong></div>
	<div>аспірант 2го року навчання</div>
	<div>Панасенко Є. С.</div>
	<div><strong>Перевірив:</strong></div>
	<div>к. ф.-м. н., доц.</div>
	<div>Турчина В.А.</div> 
</div>
<div style="font-size: 1rem; text-align:center;height:1cm;">
	м. Дніпро, 2024
</div>

# Постановка завдання

## Завдання 1

Розробити алгоритм повного перебору всіх можливих варіантів розв’язків рівняння:  
$$
x_1 + x_2 + \ldots + x_r = n, \, x_i \in \mathbb{Z}, \, i = 1, 2, \ldots, r, \, n \in \mathbb{Z}, \, n \geq 1.
$$  
Розглянути два випадки:  
- для невід'ємних $x_i$, тобто $x_i \geq 0$;  
- для додатних $x_i$, тобто $x_i > 0$.  

Алгоритм має забезпечувати перевірку розв’язків та обчислення їх кількості за відомими формулами.

## Завдання 2

1. Розробити алгоритм направленого перебору для знаходження всіх розв’язків рівняння:
	$$ x_1+2x_2+3x_3+4x_4+5x_5+6x_6+7x_7=7$$
	де $x_i$ - булеві змінні.
2. Записати рівняння в загальному вигляді і програмно реалізувати алгоритм для загального випадку.

# Запропоновані алгоритми

## Завдання 1

Алгоритм базується на рекурсивній генерації всіх можливих комбінацій значень $x_1, x_2, \ldots, x_r$, які задовольняють умову рівняння.  
Для перевірки правильності результатів використовується формула обчислення кількості розв’язків:  
$$
C = \binom{n + r - 1}{r - 1},
$$  
де $C$ — кількість розв’язків, а $r$ і $n$ — параметри задачі.

Алгоритм, реалізований у функції `gen_sols`, будує всі можливі розв’язки рівняння $\sum_{i=1}^r x_i = n$ рекурсивним методом. На кожному кроці він обирає цілочисельне значення $x_k$ із діапазону
$$\left[0, n - \sum_{j=1}^{k-1} x_j\right],$$
де $\sum_{j=1}^{k-1} x_j$ — сума вже обраних змінних на попередніх кроках. Якщо $k = r$, тобто всі $r$ змінних визначені, то розв’язок додається до результату лише за умови $\sum_{i=1}^r x_i = n$. Якщо ж $k < r$, алгоритм продовжує обирати значення для наступних змінних, доки не перебере всі можливі варіанти. Таким чином, він реалізує повний перебір усіх можливих розподілів числа $n$ на $r$ доданків. 

## Завдання 2

Запропонований алгоритм, реалізований у функції `build_tree`, можна описати математично наступним чином:

1. **Цільове рівняння**:
    $$\sum_{i=1}^n i \cdot x_i = n, \quad x_i \in \{0, 1\}.$$
2. **Вхідні дані**: $n$ — ціле число, для якого потрібно знайти всі можливі розв'язки.    
3. **Рекурсивна логіка**:
    - На кожному кроці рекурсії формується поточний вектор коефіцієнтів $\mathbf{x} = [x_1, x_2, \ldots, x_k]$, де $k$ — поточна глибина рекурсії.
    - Якщо довжина $\mathbf{x}$ дорівнює $n$, то перевіряється виконання умови: $\sum_{i=1}^n i \cdot x_i = n$. Якщо умова виконується, цей розв'язок додається до списку результатів.
    - Якщо поточна сума перевищує $n$, гілка рекурсії обривається. Тобто якщо $\sum_{i=1}^k i \cdot x_i > n$, зупинити обчислення для цієї гілки.
4. **Генерація гілок дерева**: Для кожного коефіцієнта $x_k$ є два можливі значення: $0$ або $1$. Рекурсивно обчислюються розв'язки для:
    $$\mathbf{x} + [0] \quad \text{та} \quad \mathbf{x} + [1].$$
5. **Формула загального розв'язку**: Результат функції — список всіх векторів $\mathbf{x}$, для яких виконується:
    $$\sum_{i=1}^n i \cdot x_i = n.$$

Таким чином, функція `build_tree` генерує всі можливі розв'язки шляхом перебору варіантів та фільтрації тих, які не відповідають умові рівняння.

# Програмна реалізація та результати тестування

## Завдання 1
### Програмна реалізація
Програма реалізована мовою Python. Вона генерує всі можливі розв’язки, перевіряє їхню кількість та групує рішення за максимальним значенням змінних для зручності аналізу. Код програми:

```python
from collections import defaultdict
import math

def gen_sols(sol: tuple[int, ...], n, r) -> tuple[tuple[int, ...], ...]:
    """Генерація всіх можливих сполучень для заданого n та r."""
    if len(sol) == r:
        return (sol,) if sum(sol) == n else tuple()
    out: tuple[tuple[int, ...], ...] = tuple()
    for i in range(n - sum(sol), -1, -1):
        out = out + gen_sols(sol + (i,), n, r)
    return out

def solve_and_display(n, r, limits):
    """Обчислення і друк рішень для заданих параметрів."""
    print("=" * 50)
    print(f"Рівняння: {' + '.join([f'x_{i}' for i in range(1, r + 1)])} = {n}")
    print("Обмеження: " + ", ".join([f"x_{i} >= {limits[i - 1]}" for i in range(1, r + 1)]))
    print("=" * 50)
    
    # Перевірка кількості комбінацій за допомогою формули
    n_adjusted = n - sum(limits)
    count = int(math.factorial(n_adjusted + r - 1) / (math.factorial(n_adjusted) * math.factorial(r - 1)))
    print(f"Кількість теоретичних сполучень: {count}")
    if count > 10**10:
        print(f"Неможливо перебрати всі рішення, бо кількість > {10**10}")
        return

    # Генерація всіх можливих комбінацій
    mixed_solutions = gen_sols(tuple(), n_adjusted, r)
    assert len(mixed_solutions) == count, "Генерація комбінацій не відповідає формулі."
    print("Кількість створених сполучень відповідає формулі.")

    # Приведення результатів до врахування обмежень
    all_solutions = defaultdict(list)
    for comb in mixed_solutions:
        adjusted_comb = tuple(val + limits[j] for j, val in enumerate(comb))
        all_solutions[max(adjusted_comb)].append(adjusted_comb)

    # Друк результатів
    print("Рішення згруповані за максимальним значенням змінних:")
    for max_val, group in all_solutions.items():
        print(f"Максимальне значення: {max_val}, Рішення: {group}")
    print()

# Параметри задачі
n = int(input("Введіть n: "))
r = int(input("Введіть r: "))

if int(r) <= 0 and int(n) <= 0:
    print("Ввели r<=0 або n<=0.")
    exit(0)


# Виконання програми для обох випадків обмежень
solve_and_display(n, r, [0] * r)  # Невід'ємні змінні
solve_and_display(n, r, [1] * r)  # Додатні змінні

```

### Результати тестування

Запустимо програму для $n = 5,\ r=3$:
```
$ python lab1_1.py
Введіть n: 5
Введіть r: 3
==================================================
Рівняння: x_1 + x_2 + x_3 = 5
Обмеження: x_1 >= 0, x_2 >= 0, x_3 >= 0
==================================================
Кількість теоретичних сполучень: 21
Кількість створених сполучень відповідає формулі.
Рішення згруповані за максимальним значенням змінних:
Максимальне значення: 5, Рішення: [(5, 0, 0), (0, 5, 0), (0, 0, 5)]
Максимальне значення: 4, Рішення: [(4, 1, 0), (4, 0, 1), (1, 4, 0), (1, 0, 4), (0, 4, 1), (0, 1, 4)]
Максимальне значення: 3, Рішення: [(3, 2, 0), (3, 1, 1), (3, 0, 2), (2, 3, 0), (2, 0, 3), (1, 3, 1), (1, 1, 3), (0, 3, 2), (0, 2, 3)]
Максимальне значення: 2, Рішення: [(2, 2, 1), (2, 1, 2), (1, 2, 2)]

==================================================
Рівняння: x_1 + x_2 + x_3 = 5
Обмеження: x_1 >= 1, x_2 >= 1, x_3 >= 1
==================================================
Кількість теоретичних сполучень: 6
Кількість створених сполучень відповідає формулі.
Рішення згруповані за максимальним значенням змінних:
Максимальне значення: 3, Рішення: [(3, 1, 1), (1, 3, 1), (1, 1, 3)]
Максимальне значення: 2, Рішення: [(2, 2, 1), (2, 1, 2), (1, 2, 2)]
```

Таким чином отримали:
1. **Для невід'ємних $x_i$:**
    - Теоретична кількість рішень: 21.
    - Генеровані рішення згруповані за максимальним значенням:
        - Максимальне значення 5: $(5, 0, 0), (0, 5, 0), (0, 0, 5)$.
        - Максимальне значення 4: $(4, 1, 0), (4, 0, 1), (1, 4, 0), \ldots$.
        - Максимальне значення 3 і 2: інші групи.
2. **Для додатних $x_i$:**
    - Теоретична кількість рішень: 6.
    - Генеровані рішення згруповані за максимальним значенням:
        - Максимальне значення 3: $(3, 1, 1), (1, 3, 1), (1, 1, 3)$.
        - Максимальне значення 2: $(2, 2, 1), (2, 1, 2), (1, 2, 2)$.

## Завдання 2

### Програмна реалізація

Програма реалізована мовою Python.Ця програма вирішує задачу знаходження всіх можливих розв'язків рівняння:
$$
\sum_{i=1}^ni \cdot x_i = n,
$$
де $i$ — це індекси змінних $x_i$, які можуть бути рівними 0 або 1. Програма будує дерева всіх варіантів розв'язків для заданого значення $n$, оцінюючи час обчислень за допомогою апроксимації експоненційною функцією, ґрунтуючись на попередньо обчислених значеннях для певних $n$.

Програма дозволяє користувачеві вводити значення $n$, визначає час, необхідний для обчислень, і надає можливість підтвердити, чи хоче користувач продовжити обчислення для великих значень $n$. Після виконання програма виводить усі знайдені розв'язки та час обчислення.


```python
import sys
import time
import argparse
import numpy as np
from scipy.optimize import curve_fit

# Precomputed n values for exponential fitting
PRECOMPUTED_N = np.array([20, 30, 40])

def calc_sum(coefficients):
    """Calculate the sum \u2211(i * x_i)."""
    return sum((i + 1) * coefficients[i] for i in range(len(coefficients)))

def build_tree(n, coefficients=None):
    """Recursively build solutions to \u2211(i * x_i) = n."""
    if coefficients is None:
        coefficients = []

    if len(coefficients) == n:
        return [coefficients] if calc_sum(coefficients) == n else []

    if calc_sum(coefficients) > n:
        return []

    return build_tree(n, coefficients + [0]) + build_tree(n, coefficients + [1])

def measure_precomputed_times():
    """Measure actual calculation times for precomputed n values."""
    precomputed_times = []
    for n in PRECOMPUTED_N:
        start_time = time.time()
        build_tree(n)
        end_time = time.time()
        precomputed_times.append(end_time - start_time)
    return np.array(precomputed_times)

def exponential_fit(x, a, b):
    """Exponential function for fitting: y = a * exp(b * x)."""
    return a * 2 ** (b * x)

def estimate_calculation_time(n, params):
    """Estimate the time required for the calculation using the exponential fit."""
    a, b = params
    return exponential_fit(n, a, b)

def format_solution(solution):
    """Format a solution as a formula."""
    terms = [f"{i + 1}*x_{i + 1}" for i, x in enumerate(solution) if x == 1]
    return " + ".join(terms) + f" = {sum((i + 1) * solution[i] for i in range(len(solution)))}"

def main():
    parser = argparse.ArgumentParser(description="Знайти розв'язки рівняння \u2211(i * x_i) = n.")
    parser.add_argument("n", type=int, nargs="?", help="Цільове значення n для рівняння.")
    parser.add_argument("-y", action="store_true", help="Пропустити підтвердження для великих значень n.")
    args = parser.parse_args()

    # Get target value n from arguments or input
    if args.n is not None:
        n = args.n
    else:
        try:
            n = int(input("Введіть цільове значення n: "))
        except ValueError:
            print("Неправильне введення. Будь ласка, введіть ціле число.")
            sys.exit(1)

    # Validate n
    if n < 0:
        print("Значення n не може бути від'ємним.")
        sys.exit(1)

    print(f"Кількість варіантів розв'язків: {2 ** n}")

    # Measure precomputed times and fit exponential curve
    precomputed_times = measure_precomputed_times()
    params, _ = curve_fit(exponential_fit, PRECOMPUTED_N, precomputed_times)

    # Estimate calculation time
    estimated_time = estimate_calculation_time(n, params)
    print(f"Оцінений час для обчислення: {estimated_time:.2f} секунд.")

    # Confirm calculation if time is large
    if estimated_time >= 10 and not args.y:
        print(f"Обчислення для n = {n} оцінюється в {estimated_time:.2f} секунд.\nВи впевнені, що хочете продовжити? (y/n)")
        confirm = input().strip().lower()
        if confirm != 'y':
            print("Обчислення скасовано.")
            sys.exit(0)

    # Perform calculation
    start_time = time.time()
    solutions = build_tree(n)
    end_time = time.time()

    # Output results
    print(f"Знайдено {len(solutions)} розв'язків для n = {n}:")
    for solution in solutions:
        print(format_solution(solution))

    print(f"Обчислення завершено за {end_time - start_time:.2f} секунд.")

if __name__ == "__main__":
    main()

```


### Результати тестування

Вікно допомоги:
```
$ python lab1_2.py -h
usage: lab1_2.py [-h] [-y] [n]

Знайти розв'язки рівняння ∑(i * x_i) = n.

positional arguments:
  n           Цільове значення n для рівняння.

options:
  -h, --help  show this help message and exit
  -y          Пропустити підтвердження для великих значень n.
```

Запустимо програму за постановкою задачі при $n=7$:
```
$ python lab1_2.py
Введіть цільове значення n: 7
Кількість варіантів розв'язків: 128
Оцінений час для обчислення: 0.00 секунд.
Знайдено 5 розв'язків для n = 7:
7*x_7 = 7
3*x_3 + 4*x_4 = 7
2*x_2 + 5*x_5 = 7
1*x_1 + 6*x_6 = 7
1*x_1 + 2*x_2 + 4*x_4 = 7
Обчислення завершено за 0.00 секунд.
```

Програма знайшла 5 розв'язків для рівняння:
$$\sum_{i=1}^ni \cdot x_i = 7$$
де $x_i$ може бути рівним 0 або 1 для кожного $i$. Кожен розв'язок представляється як сума добутків індексів $i$ і відповідних змінних $x_i$, де $x_i = 1$, якщо цей індекс входить у розв'язок.

Розв'язки:
1. $7 \cdot x_7 = 7$
2. $3 \cdot x_3 + 4 \cdot x_4 = 7$
3. $2 \cdot x_2 + 5 \cdot x_5 = 7$
4. $1 \cdot x_1 + 6 \cdot x_6 = 7$
5. $1 \cdot x_1 + 2 \cdot x_2 + 4 \cdot x_4 = 7$

Ці рівняння описують різні комбінації індексів $i$, для яких добуток $i \cdot x_i$ дає суму 7. Всі можливі варіанти розв'язків можна отримати, комбінуючи індекси з $x_i = 1$ таким чином, щоб сума відповідних добутків дорівнювала 7.

Оскільки кількість варіантів розв'язків для заданого значення $n = 7$ дорівнює $2^7 = 128$, програма перераховує всі ці варіанти і знаходить тільки ті, що дають правильну суму.

Протестуємо програму при дуже великих значеннях
```
$ python lab1_2.py 60
Кількість варіантів розв'язків: 1152921504606846976
Оцінений час для обчислення: 24.67 секунд.
Обчислення для n = 60 оцінюється в 24.67 секунд.
Ви впевнені, що хочете продовжити? (y/n)
n
Обчислення скасовано.
```


## Висновки

Програми для завдань 1 та 2 успішно вирішують поставлене завдання, генерують всі можливі розв’язки та підтверджують їх кількість відповідно до формули. Результати представлені в зручному форматі для аналізу.